/*
 * Atmega16_test.cpp
 *
 * Created: 11.04.2022 21:44:49
 * Author : Иван
 */ 

#include <avr/io.h>
#define F_CPU 8000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdlib.h>


void PWM_set()
{
	OCR0 = 0;
	DDRB |= 1<<DDB3;
	TCCR0 |= (1<<COM01)|(0<<WGM01)|(1<<WGM00)|(0<<CS02)|(1<<CS01)|(0<<CS00);
}

unsigned int ADC_read()
{
	// chnl= chnl & 0b00000111; // выбор канала АЦП от 0 до 7
	ADMUX = 0x40;        // выбран канал A0
	ADCSRA|=(1<<ADSC);   // старт преобразования
	while(!(ADCSRA & (1<<ADIF)));   // ждем окончания преобразования
	ADCSRA|=(1<<ADIF);   // очистим ADIF когда преобразование закончится
	return (ADC); // возвращаем рассчитанное значение АЦП
}

void LED (unsigned int percent)
{
	int level = percent / 10;
	switch ( level )
	{
		case 0: 
			PORTD = 0b00000000;
			break;
		case 1:
			PORTD = 0b10000000;
			break;
		case 2:
			PORTD = 0b11000000;
			break;
		case 3:
			PORTD = 0b11000100;
			break;
		case 4:
			PORTD = 0b11100100;
			break;
		case 5:
			PORTD = 0b11100110;
			break;
		case 6:
			PORTD = 0b11110110;
			break;
		case 7:
			PORTD = 0b11110110; // ignore HL2
			// PORTD = 0b11110111;
			break;
		case 8:
			PORTD = 0b11111110; // ignore HL2
			// PORTD = 0b11111111;
			break;
		case 9:
			PORTD = 0b10000000;
			break;
		case 10:
			PORTD = 0b11000000;
			break;
		default:
			PORTD = 0b00000000;
			break;
	}
}

unsigned int to_percent(unsigned ADC_number)
{
	unsigned int number_o = (float) ADC_number / 1023 * 100;
	return(number_o);
}

void deshifr(unsigned int number)
{
	unsigned int firstnumber = 10;
	unsigned int secondnumber = 10;
	unsigned int thirdnumber = 10;
	
	if (number < 10)
	{
		thirdnumber = number;
		secondnumber = 10;
		firstnumber = 10;
		} else {
		if (number < 100)
		{
			thirdnumber = number % 10;
			secondnumber = number / 10;
			firstnumber = 10;
			} else {
			firstnumber = 1;
			secondnumber = 0;
			thirdnumber = 0;
		}
	}
	PORTB = 0b00000011;
	switch ( thirdnumber ) {
		case 0:
		PORTC = 0x3F;
		break;
		case 1:
		PORTC = 0x06;
		break;
		case 2:
		PORTC = 0x5B;
		break;
		case 3:
		PORTC = 0x4F;
		break;
		case 4:
		PORTC = 0x66;
		break;
		case 5:
		PORTC = 0x6D;
		break;
		case 6:
		PORTC = 0x7D;
		break;
		case 7:
		PORTC = 0x07;
		break;
		case 8:
		PORTC = 0x7F;
		break;
		case 9:
		PORTC = 0x6F;
		break;
		default:
		PORTC = 0x00;
		break;
	}
	_delay_ms(1);
	PORTB = 0b00000101;
	switch ( secondnumber ) {
		case 0:
		PORTC = 0x3F;
		break;
		case 1:
		PORTC = 0x06;
		break;
		case 2:
		PORTC = 0x5B;
		break;
		case 3:
		PORTC = 0x4F;
		break;
		case 4:
		PORTC = 0x66;
		break;
		case 5:
		PORTC = 0x6D;
		break;
		case 6:
		PORTC = 0x7D;
		break;
		case 7:
		PORTC = 0x07;
		break;
		case 8:
		PORTC = 0x7F;
		break;
		case 9:
		PORTC = 0x6F;
		break;
		default:
		PORTC = 0x00;
		break;
	}
	_delay_ms(1);
	PORTB = 0b00000110;
	switch ( firstnumber ) {
		case 0:
		PORTC = 0x3F;
		break;
		case 1:
		PORTC = 0x06;
		break;
		case 2:
		PORTC = 0x5B;
		break;
		case 3:
		PORTC = 0x4F;
		break;
		case 4:
		PORTC = 0x66;
		break;
		case 5:
		PORTC = 0x6D;
		break;
		case 6:
		PORTC = 0x7D;
		break;
		case 7:
		PORTC = 0x07;
		break;
		case 8:
		PORTC = 0x7F;
		break;
		case 9:
		PORTC = 0x6F;
		break;
		default:
		PORTC = 0x00;
		break;
	}
	_delay_ms(1);
}

int main(void)
{
	DDRA = 0x00;
	DDRB = 0x0F;
	DDRC = 0xFF;
	DDRD = 0xFF;
	PORTA = 0x1E;
	PORTB = 0x00;
	PORTD = 0x09;
	ADMUX=(0<<REFS0);      // выбор внешнего опорного напряжения
	ADCSRA=(1<<ADEN)|(0<<ADPS2)|(0<<ADPS1)|(1<<ADPS0);     // разрешаем АЦП и устанавливаем коэффициент деления предделителя
	PWM_set();
	int encoder;
	
    /* Replace with your application code */
    while (1) 
    {
		encoder = to_percent(ADC_read());
		OCR0 = 180 / 100 * encoder;
		LED(encoder);
		deshifr(encoder);
	}
}