/*
 * Atmega16_test.cpp
 *
 * Created: 11.04.2022 21:44:49
 * Author : Иван
 */ 

#include <avr/io.h>
#define F_CPU 8000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdlib.h>


unsigned int ADC_read(unsigned char chnl)
{
	chnl= chnl & 0b00000111; // выбор канала АЦП от 0 до 7
	ADMUX = 0x40;        // выбран канал A0
	ADCSRA|=(1<<ADSC);   // старт преобразования
	while(!(ADCSRA & (1<<ADIF)));   // ждем окончания преобразования
	ADCSRA|=(1<<ADIF);   // очистим ADIF когда преобразование закончится
	return (ADC); // возвращаем рассчитанное значение АЦП
}

unsigned int to_percent(unsigned ADC_number)
{
	unsigned int number_o = (float) ADC_number / 1023 * 100;
	return(number_o);
}

void deshifr(unsigned int number)
{
	unsigned int firstnumber = 10;
	unsigned int secondnumber = 10;
	unsigned int thirdnumber = 10;
	
	if (number < 10)
	{
		thirdnumber = number;
		secondnumber = 10;
		firstnumber = 10;
	} else {
		if (number < 100)
		{
			thirdnumber = number % 10;
			secondnumber = number / 10;
			firstnumber = 10;
		} else {
			firstnumber = 1;
			secondnumber = 0;
			thirdnumber = 0;
		}
	}
	PORTB = 0b00000011;
	switch ( thirdnumber ) {
		case 0:
			PORTC = 0b00111111;
			break;
		case 1:
			PORTC = 0b00000110;
			break;
		case 2:
			PORTC = 0b01011011;
			break;
		case 3:
			PORTC = 0b01001111;
			break;
		case 4:
			PORTC = 0b01100110;
			break;
		case 5:
			PORTC = 0b01101101;
			break;
		case 6:
			PORTC = 0b01111101;
			break;
		case 7:
			PORTC = 0b00000111;
			break;
		case 8:
			PORTC = 0b01111111;
			break;
		case 9:
			PORTC = 0b01101111;
			break;
		default:
			PORTC = 0b00000000;
			break;
	}
	_delay_ms(1);
	PORTB = 0b00000101;
	switch ( secondnumber ) {
		case 0:
			PORTC = 0b00111111;
			break;
		case 1:
			PORTC = 0b00000110;
			break;
		case 2:
			PORTC = 0b01011011;
			break;
		case 3:
			PORTC = 0b01001111;
			break;
		case 4:
			PORTC = 0b01100110;
			break;
		case 5:
			PORTC = 0b01101101;
			break;
		case 6:
			PORTC = 0b01111101;
			break;
		case 7:
			PORTC = 0b00000111;
			break;
		case 8:
			PORTC = 0b01111111;
			break;
		case 9:
			PORTC = 0b01101111;
			break;
		default:
			PORTC = 0b00000000;
			break;
	}
	_delay_ms(1);
	PORTB = 0b00000110;
	switch ( firstnumber ) {
		case 0:
			PORTC = 0b00111111;
			break;
		case 1:
			PORTC = 0b00000110;
			break;
		case 2:
			PORTC = 0b01011011;
			break;
		case 3:
			PORTC = 0b01001111;
			break;
		case 4:
			PORTC = 0b01100110;
			break;
		case 5:
			PORTC = 0b01101101;
			break;
		case 6:
			PORTC = 0b01111101;
			break;
		case 7:
			PORTC = 0b00000111;
			break;
		case 8:
			PORTC = 0b01111111;
			break;
		case 9:
			PORTC = 0b01101111;
			break;
		default:
			PORTC = 0b00000000;
			break;
	}
	_delay_ms(1);
}

int main(void)
{
	DDRB = 0b00000111;
	PORTB = 0b00000110;
	DDRD = 0xFF;
	PORTD = 0b00001001;
	DDRC = 0xFF;
	PORTC = 0b11111111;       // устанавливаем на всех контактах PORTC значения
	ADMUX=(0<<REFS0);      // выбор внешнего опорного напряжения
	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);     // разрешаем АЦП и устанавливаем коэффициент деления предделителя
	
	
    /* Replace with your application code */
    while (1) 
    {	
		deshifr(to_percent(ADC_read(0)));
    }
}

